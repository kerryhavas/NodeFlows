
var logManager = require('./logManager.js');
var log = require('./logManager.js').log;
var queueManager = require("./queueManager.js");

var nodeFlows = require('./nodeFlows');
var historyManager = require('./historyManager');
var workflowManager = require("./workflowManager.js");
var statManager = require("./statManager.js");

var logHistoryHydration = false;

exports.SUBSYSTEM = "queueItem";
exports.MODULE = "queueItem";

exports.QueueItem = function QueueItem(type, priority, work) {

    if (type._id !== undefined) {
        //log("This is a persisted item being reloaded");
        this.hydrate(type);
        if (logHistoryHydration) this.addHistory({ task: "Hydrated", notes: JSON.stringify(this) })
    }
    else {
        log("This is a new queueItem");
        this.type = type;
        this.priority = priority;
        //this.work = work;
        this.lockedBy = null;
        this.dateAdded = nodeFlows.getRelativeTime();
        this.workflowId = null;
        this.queueWorkerId = null;
        this.initiatingQueueItemId = null;

        if (work.initiatingQueueItemId != undefined) {
            this.initiatingQueueItemId = work.initiatingQueueItemId;
        }
        else {
            this.initiatingQueueItemId = null;
        }
        this.timeStamp = new Date().getTime();
        this.status = queueManager.QUEUE_ITEM_STATUS.BUSY;
        this._id = queueManager.getUniqueId();
        this.activityCount = 0;
        this.idleCount = 0;
        this.busyCount = 0;

        this.addHistory({ task: "QueueItemCreated", notes: "Type:" + type + "   Priority:" + priority + " initiatingQueueItemId:" + this.initiatingQueueItemId })

        this.SUBSYSTEM = "Queue";
        this.MODULE = "queueItem";

        //Persistence is async
        this.persist(function (queueItem) {
            //How should I wait for this in constructor?
        });
    }
};

exports.QueueItem.prototype = {

    persist: function (callback) {
        logManager.throwIfUndefined(callback, "A callback is needed");

        log("persist", "", exports.SUBSYSTEM);
        nodeFlows.persistenceManager.insertQueueItemInstance(this, function (queueItem) {
            callback();
        });

    },
    hydrate: function (persistedData) {
        //logManager.log("Hydrating queueItem:" + JSON.stringify(persistedData), "", exports.SUBSYSTEM);
        //TODO does this need a deep copy?
        for (var property in persistedData) {
            this[property] = persistedData[property];
        }
        //logManager.log("queueItem after hydration:" + JSON.stringify(this), "", exports.SUBSYSTEM);
    },
    addHistory: function (history) {
        try {

            //return if history is disabled
            if (!queueManager.queueItemHistoryEnabled) return;

            if (this.workflowId !== null) {
                if (history.workflowId === undefined) {
                    history.workflowId = this.workflowId;
                }
            };

            if (this.queueWorkerId !== null) {
                if (history.queueWorkerId === undefined) {
                    history.queueWorkerId = this.queueWorkerId;
                }
            };

            statManager.statsEmitter.emit('History', { subsystem: queueManager.SUBSYSTEM_QUEUEITEM, id: this._id, history: history });

            //historyManager.addHistory(nodeFlows.SUBSYSTEM_QUEUEITEM, this._id, history);

            if (this.initiatingQueueItemId != undefined) {
                queueManager.getQueueItem(this.initiatingQueueItemId, function (initiatingQueueItem) {
                    if (initiatingQueueItem == undefined) {
                        logManager.log("Unable to load InitiatingQueueItem:" + this.initiatingQueueItemId, "", exports.SUBSYSTEM);
                        //This is likely due to the fact that it was completed and removed from the queue
                        //Not a big deal
                    }
                    else {
                        //history.task = "=>" + history.task;
                        //TODO do we want to propogate history up?
                        //initiatingQueueItem.addHistory(history);
                    }
                });
            }
        }
        catch (ex) {
            logManager.logException(ex);
        }
    },
    getWorkflow: function getWorkflow(callback) {
        log("queueItem_getWorkflow:" + this.workflowId, "", exports.SUBSYSTEM);
        statManager.statsEmitter.emit('StatEvent2', { subsystem: this.SUBSYSTEM, module: this.MODULE, statName: "getWorkflow" });
        nodeFlows.persistenceManager.retrieveWorkflowInstance(this.workflowId, function (workflow) {
            log("Retrieved Workflow from persistence", "", exports.SUBSYSTEM);
            callback(workflow);
        });
    },
    updateQueueItem: function (updateData, callback) {
        logManager.log("updateQueueItem:" + this._id.toString());
        this.addHistory({ task: "UpdateReceived", notes: JSON.stringify(updateData) });

        //Update local copy
        for (var property in updateData) {
            logManager.log("Updating property:" + property + " to " + updateData[property]);
            this[property] = updateData[property];
            this.addHistory({ task: "SetProperty", notes: property + "=" + updateData[property] });
        };

        var currentQueueItem = this;
        nodeFlows.persistenceManager.updateQueueitemWithData(this._id, updateData, function () {
            callback();
            if (currentQueueItem.status === "resume"){
                currentQueueItem.addHistory({ task: "Resuming", notes: "" });
                statManager.statsEmitter.emit('QueueWorkerNeeded', currentQueueItem);
            }
        });





    },
    getQueueWorker: function () {
        log("queueItem_getQueueWorker:" + this.queueWorkerId, "", exports.SUBSYSTEM);
        return queueManager.getQueueWorker(this.queueWorkerId);
    },
    queueItemComplete: function (status, callback) {

        try {
            this.addHistory({ task: "queueItemComplete", notes: "status:" + status });

            this.status = queueManager.QUEUE_ITEM_STATUS.DONE;
            this.lockedBy = null;
            this.lastQueueWorkerId = this.queueWorkerId;

            var queueWorker = this.getQueueWorker();
            if (queueWorker !== null) {
                queueWorker.releaseQueueWorker("queueItemComplete");
            }
            this.queueWorkerId = null;
            this.completed = new Date().getTime();


            var queueItemId = this._id;

            nodeFlows.persistenceManager.persistQueueItemToHistory(this, function () {
                nodeFlows.persistenceManager.removeQueueItem(queueItemId);
            });

            //  process.nextTick(function () {
            //      queueManager.moveQueueItemToHistory(queueItemId);
            //  });

            callback();

        }
        catch (ex) {
            logManager.logException(ex);
        }
    },
    workItemBlocked: function (notes) {

        if (notes === undefined) notes = "workItemBlocked";

        this.status = queueManager.QUEUE_ITEM_STATUS.BLOCKED;

        var queueWorker = this.getQueueWorker();
        queueWorker.releaseQueueWorker(notes);

    }
};
