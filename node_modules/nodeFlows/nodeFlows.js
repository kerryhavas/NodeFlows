//Relative starting time which everything can use to show more granular timings (in ms)
var globalStartTick = new Date().getTime();

var Events = require('events');
var fs = require("fs");
var persistenceProvider = "";


var globalSettingsManager = require("./globalSettings");

var logManager = require("./logManager");

process.on('uncaughtException', function (err) {
  logManager.logException(err, "uncaughtException:" + err);
});

var statManager = require("./statManager");
var activityManager = require("./activityManager");
var workflowManager = require("./workflowManager");
var queueManager = require("./queueManager");
var Workflow = require('./workflow').Workflow;
var historyManager = require('./historyManager');
var ObjectID = require('mongodb').ObjectID;

//var profiler = require('./v8-profiler');




var eventEmitter = new Events.EventEmitter;

exports.getUniqueId = getUniqueId;
exports.processWorkflow = processWorkflow;
exports.updateWorkflow = updateWorkflow;
exports.createWorkflow = createWorkflow;
exports.deleteWorkflow = deleteWorkflow;
exports.getWorkflow = getWorkflow;
exports.processWorkflow = processWorkflow;
exports.log = logManager.log;
exports.getStats = getStats;
exports.workflowManager = workflowManager;
exports.queueManager = queueManager;
exports.logManager = logManager;
exports.statManager = statManager;
exports.persistenceManager = persistenceManager;
exports.getRelativeTime = getRelativeTime;
exports.historyManager = historyManager;
exports.getQueueItemHistoryCount = getQueueItemHistoryCount;
exports.getWorkflowHistoryCount = getWorkflowHistoryCount;
exports.getGlobalSettings = getGlobalSettings;


//Subsystems
exports.SUBSYSTEM_QUEUEWORKER = "queueWorker";
exports.SUBSYSTEM_QUEUEITEM = "queueItem";
exports.SUBSYSTEM_WORKFLOW = "workflow";



applyGlobalSettings(globalSettingsManager.globalSettings);

var persistenceProvider;
var persistenceManager = require("./" + persistenceProvider);

Object.defineProperty(exports, 'persistenceManager', {
    get: function () {
        //log("Returning the persistence provider")
        return persistenceManager;
    }
});

//TODO make a link in the site
persistenceManager.initializeStorage();


var io = require('socket.io').listen(8080);

logManager.log("Node Version:" + process.version);
logManager.log("Other Versions:" + JSON.stringify(process.versions));


var connectedSocket;

function getGlobalSettings(){
    return globalSettings;
}

function applyGlobalSettings(globalSettings){
    logManager.logToConsole = globalSettings.logToConsole;
    logManager.logToMemory = globalSettings.logToMemory;
    historyManager.historyEnabled = globalSettings.historyEnabled;
    log("Getting workflowHistoryEnabled:" + workflowManager.workflowHistoryEnabled);
    log("Setting workflowHistoryEnabled to:" + globalSettings.workflowHistoryEnabled);
    workflowManager.workflowHistoryEnabled = globalSettings.workflowHistoryEnabled;
    log("Getting workflowHistoryEnabled2:" + workflowManager.workflowHistoryEnabled);
    queueManager.queueWorkerHistoryEnabled = globalSettings.queueWorkerHistoryEnabled;
    queueManager.queueItemHistoryEnabled = globalSettings.queueItemHistoryEnabled;
    persistenceProvider = globalSettings.persistenceProvider;
    historyManager.writeHistoryToLog = globalSettings.writeHistoryToLog;


}

function getUniqueId(){
    return new ObjectID().toString();
}

//Relative time since this service started up
function getRelativeTime(){
    try{
    return (new Date().getTime()) - globalStartTick;
    }
    catch(ex)
    {
        return -1;
    }
}

io.configure(function () { 
  io.set("transports", ["xhr-polling"]); 
  io.set("polling duration", 100); 
});

io.sockets.on('connection', function (socket) {
    connectedSocket = socket;
    connectedSocket.volatile.emit('announcement', { announcement: 'hello' });
});

io.sockets.on('disconnect', function (socket) {
    connectedSocket = null;
    //connectedSocket.broadcast.emit('announcement', { announcement: 'You are connected' });
});


statManager.statsEmitter.on('deleteWorkflowInstance', function(args) {
    deleteWorkflow(args.workflowId, args, function(workflow) {
        //do nothing
    });
});



statManager.statsEmitter.on('WorkflowEvent', function (statName) {
    if (connectedSocket !== undefined) {
        if (statName === 'PizzasCooked' ||  statName === 'PizzasDelivered' ) {
            //connectedSocket.volatile.emit('announcement', { announcement: statName });
        }
    }
}); 

statManager.statsEmitter.on('StatUpdate', function (stat) {
    if (connectedSocket !== undefined) {
        //      connectedSocket.volatile.emit('status', stat );
        if (stat.name === 'PizzasCooked' ||  stat.name === 'PizzasDelivered' ) {
            connectedSocket.volatile.emit('status', stat );
        }
    }
}); 




function getStats() {
    return statManager.getStats();
}

function log(text, level) {
    logManager.log(text, level);
}

function getQueueItemHistoryCount(callback){
    logManager.throwIfUndefined(callback, "A callback is needed");

    queueManager.getQueueItemHistoryCount(function (itemCount) {
        callback(itemCount);
    });
};

function getWorkflowHistoryCount(callback){
    logManager.throwIfUndefined(callback, "A callback is needed");

    workflowManager.getWorkflowHistoryCount(function (count) {
        callback(count);
    });

}

function createWorkflow(workflowType, initialData, callback) {
    logManager.log("createWorkflow of type:" + workflowType);
    logManager.log("Parameters:" + JSON.stringify(initialData.parameters));

    var workflow = new Workflow(workflowType,initialData);

    workflow.addHistory({ task: "Parameters", notes: JSON.stringify(initialData.parameters) });
    //logManager.log("Initialized Workflow:" + JSON.stringify(workflow));

    persistenceManager.insertWorkflowInstance(workflow, function() {
        statManager.statsEmitter.emit('StatEvent', "WorkflowCreated");
        statManager.statsEmitter.emit('StatEvent', "Workflow:" + workflowType);
        callback(workflow);
    });

}

function deleteWorkflow(workflowid, callback) {
    logManager.log("deleteWorkflow:" + workflowid);
    getWorkflow(workflowid, function (err, workflow) {
        //Go ahead and close out the underlying queueItem for the workflow
        if (workflow !== undefined) {
            try {
                var queueItem = workflow.getQueueItem();
                if (queueItem !== undefined) {
                    queueItem.queueItemComplete("Deleted", function () {
                        //We dont need to wait on this to complete
                    });
                }
                else
                {
                    logManager.log("Could not delete null queueItem:" + workflowid);
                }
            }
            catch (ex) {
                logManager.logException(ex, "Deleting workflow queueItem failed");
            }
        }

        persistenceManager.removeWorkflowInstance(workflowid, function () {
            statManager.statsEmitter.emit('StatEvent', "deleteWorkflow");
            if (callback != undefined) {
                callback();
            }
        });
    });

}

function getWorkflow(workflowId, callback) {
    logManager.log("getWorkflow:" + workflowId);
    statManager.statsEmitter.emit('StatEvent2', {subsystem:"nodeFlows",module:"Main",statName:"getWorkflow"});
    persistenceManager.retrieveWorkflowInstance(workflowId, function(workflow) {
        callback(null, workflow);
    });
}

function updateWorkflow(workflowId, updateData, callback) {
    logManager.log("updateWorkflow:" + workflowId);
    persistenceManager.updateWorkflowInstance(workflowId, updateData, function() {
        if(callback != undefined) {
            callback(null); //TODO: add error handling
        }
        
    });
}

function processWorkflow(workflowId) {
    statManager.statsEmitter.emit('StatEvent', "processWorkflow");
    if(typeof (workflowId) == "string") { 
        logManager.log("processWorkflowById:" + workflowId);
        //passed in the workflowid
        getWorkflow(workflowId, function (err, workflow) {
            workflow.processWorkflow();
        });
    }
    else {
        var workflow = workflowId;  //passed in the actual workflow
        workflow.processWorkflow();
    };
};

/* 
* Recursively merge properties of two objects  
*/ 
function MergeRecursive(obj1, obj2) { 
 
  for (var p in obj2) { 
    try { 
      // Property in destination object set; update its value. 
      if ( obj2[p].constructor==Object ) { 
        obj1[p] = MergeRecursive(obj1[p], obj2[p]); 
 
      } else { 
        obj1[p] = obj2[p]; 
 
      } 
 
    } catch(e) { 
      // Property in destination object not set; create it and set its value. 
      obj1[p] = obj2[p]; 
 
    } 
  } 
 
  return obj1; 
} 
