//Queue manager

var logManager = require('./logManager.js');
var log = require('./logManager.js').log;
var logException = require('./logManager.js').logException;
var logError = require("./logManager.js").logError;
var nodeFlows = require('./nodeFlows');
var workflowManager = nodeFlows.workflowManager;
var QueueWorker = require('./queueWorker').QueueWorker;
var QueueItem = require('./queueItem').QueueItem;
var stats = require("./statManager.js");
var queueItemHistoryEnabled = true;

var queueItemStatus = {
    PAUSED: "Paused",
    DONE: "Done",
    BUSY: "busy",
    ERROR: "Error",
    IDLE: "idle",
    SLEEPING: "sleeping",
    WAITING: "waiting",
    BLOCKED: "blocked"
};


Object.defineProperty(exports, 'queueItemHistoryEnabled', {
    get: function () {
        //log("Get queueItemHistoryEnabled:" + queueItemHistoryEnabled);
        return queueItemHistoryEnabled;
    },
    set: function (val) {
        //log("Set queueItemHistoryEnabled to:" + val);
        queueItemHistoryEnabled = val;
    }
});

var queueWorkerHistoryEnabled = true;

Object.defineProperty(exports, 'queueWorkerHistoryEnabled', {
    get: function () {
        //log("Get queueWorkerHistoryEnabled:" + queueWorkerHistoryEnabled);
        return queueWorkerHistoryEnabled;
    },
    set: function (val) {
        //log("Set queueWorkerHistoryEnabled to:" + val);
        queueWorkerHistoryEnabled = val;
    }
});


exports.QUEUE_ITEM_STATUS = queueItemStatus;


exports.addQueueWorker = addQueueWorker;
exports.enqueue = enqueue;
exports.getQueue = getQueue;
exports.getQueueWorkers = getQueueWorkers;
exports.getWorkerHistory = getWorkerHistory;
exports.getQueueItemHistory = getQueueItemHistory;
exports.getQueueHistory = getQueueHistory;
exports.getQueueWorker = getQueueWorker;
exports.getQueueItem = getQueueItem;
exports.enqueueAsync = enqueueAsync;
exports.moveQueueItemToHistory = moveQueueItemToHistory;
exports.lookForNewWork = lookForNewWork;
exports.getUniqueId = getUniqueId;
exports.findIdleWorker = findIdleWorker;
exports.getQueueItemHistoryCount = getQueueItemHistoryCount;
//exports.queueWorkerHistoryEnabled = queueWorkerHistoryEnabled = false;

exports.SUBSYSTEM = "queueManager";

exports.SUBSYSTEM_QUEUEWORKER = "queueWorker";
exports.SUBSYSTEM_QUEUEITEM = "queueItem";



var counter = 0;
//var queueStorage = {};
//var queueItemHistory = {};
var queueWorkers = {};



var lookForWorkInterval = 100;

function getUniqueId(){
    return nodeFlows.getUniqueId();
}

var interval = setInterval(function () {
    //logManager.log('queueManager Timer:' + counter);
    for (var workerId in queueWorkers) {
        if (workerId != undefined) {
            //logManager.log('Checking for new work for worker:' + worker);
                //lookForNewWork(workerId);
        }
    }
    counter++;
}, lookForWorkInterval);


function getQueueItemHistoryCount(callback){
    logManager.throwIfUndefined(callback, "A callback is needed");
    //return Object.keys(queueItemHistory).length;
    nodeFlows.persistenceManager.getQueueItemHistoryCount(function (itemCount) {
        callback(itemCount);
    });
};

function getQueueHistory(callback) {
    logManager.throwIfUndefined(callback, "A callback is needed");

    nodeFlows.persistenceManager.getQueueHistory(function (items) {
        callback(items);
    });
}


function getQueueWorkers() {
    var queue = [];
    for(var property in queueWorkers) {
        queue.push(queueWorkers[property]);
    }
    return queue;
}

function getQueue(callback) {
    logManager.throwIfUndefined(callback, "A callback is needed");
   // var queue = [];
    //for(var property in queueStorage) {
    //    queue.push(queueStorage[property]);
   // }
    nodeFlows.persistenceManager.getQueue(function (queue) {
        callback(queue);
    });
    //return queue;
}


function enqueueAsync(work){
    logManager.log("enqueueAsync:"+ JSON.stringify(work), "", exports.SUBSYSTEM);
    process.nextTick(function () {
       logManager.log("enqueueAsync_Process:" + JSON.stringify(work), "", exports.SUBSYSTEM);
       enqueue(1, work);
    });
}

function enqueue(priority, work) {

    var type = work.workflowDefinition;

    logManager.log("enqueuing: type:" + type + " priority:" + priority + " work:" + JSON.stringify(work), "", exports.SUBSYSTEM);

    work.startTimeStamp = new Date().getTime();

    var queueItem = new QueueItem(type,priority,work);

    //queueStorage[queueItem._id] = queueItem;

    work.queueItemId = queueItem._id;
    queueItem.status = exports.QUEUE_ITEM_STATUS.WAITING;

    nodeFlows.createWorkflow(type, work, function (workflow) {

        //check for idle workers
        log("queueManager_enqueue FindIdleWorker", "", exports.SUBSYSTEM);
        queueItem.workflowId = workflow._id;

        stats.statsEmitter.emit('QueueWorkerNeeded', queueItem);

//        findIdleWorker(queueItem, workflow, function (queueWorker) {
//            if (queueWorker === undefined) {
//                logManager.log("queueManager>Did not find available worker!");
//                queueItem.addHistory({ task: "NoWorker", queueItemId: work.initiatingQueueItemId, notes: type + " subtask queueItemId:" + queueItem._id });
//            }
//        });
    });
}

function findIdleWorker(queueItem, workflow, callback){
    log("queueManager_findIdleWorker:" + workflow.workflowType, "", exports.SUBSYSTEM);

    for (var queueWorkerId in queueWorkers) {
        var queueWorker = queueWorkers[queueWorkerId];
        //log("comparing worker:" + queueWorker.type + " to " + workflow.workflowType + " status:" + queueWorker.status);
        if (queueWorker.type == workflow.workflowType && queueWorker.status == QueueWorker.prototype.STATUS_IDLE) {
            logManager.log("Found Idle Worker", "", exports.SUBSYSTEM);
            queueWorker.addHistory({ task: "FoundIdle" });
            queueWorker.takeQueueItem(queueItem);
            workflow.queueWorkerId = queueWorker._id;
            process.nextTick(function () {
                workflow.processWorkflow();
            });
            stats.statsEmitter.emit('StatEvent', "FoundIdle_" + workflow.workflowType);
            callback(queueWorker);
            return;
        }
    }
    log("No idle worker Found for type:" + workflow.workflowType, "", exports.SUBSYSTEM);
    stats.statsEmitter.emit('StatEvent', "Busy_" + workflow.workflowType);
    callback(undefined);
}

function dequeue(type, callback) {
    for(var property in queueStorage) {
        if(queueStorage[property].type == type && !queueStorage[property].locked) {
            queueStorage[property].locked = true;  //someone is processing this.
             callback(queueStorage[property])
             return;
        }
    }
}

function addQueueWorker(type)
{
    logManager.log("Adding Queue Worker type:" + type, "", exports.SUBSYSTEM);

    var queueWorker = new QueueWorker(type);

    queueWorkers[queueWorker._id] = queueWorker;
    queueWorker.addHistory({task: "Initialized", queueItem: null, workflow: null });

    queueWorker.process();


}



function removeQueueWorker(type){

    logError("queueManager_removeQueueWorker Not Implemented");
}

function getQueueItemHistory(queueItemId) {
   // var queueItem;
  //  if(queueStorage[queueItemId] == undefined) {
   //     queueItem = queueItemHistory[queueItemId];
   // }
   // else {
   //     queueItem = queueStorage[queueItemId];
   // }
    //return queueItem.history;

    return nodeFlows.persistenceManager.getQueueItemHistory(queueItemId);

}

function getWorkerHistory(workerId) {
    var queueWorker = queueWorkers[workerId];
    return queueWorker.history;
}



function addQueueItemHistory(workerId, history) {
    try {
        history.timeStamp = new Date().getTime();

        if(history.queueItemId != undefined) {
            var queueItem = queueStorage[history.queueItemId];
            history.queueWorkerId = workerId;
            if(queueItem == undefined) {
                logError("queueItem not found:" + history.queueItemId + " History:" + JSON.stringify(history));
            } else {
                queueItem.history.push(history);
            }
        }
    }
    catch(ex) {
        logManager.logException(ex);
    }
}


function getQueueWorker(queueWorkerId) {
    return queueWorkers[queueWorkerId];
}

function getQueueItem(queueItemId, callback) {
    if (queueItemId===null){
        throw new Error("queueItemId cant be null");
    };
    logManager.throwIfUndefined(callback, "A callback is needed");

    //logManager.logCallStack();

    nodeFlows.persistenceManager.getQueueItem(queueItemId, function (queueItem) {
        if (queueItem === undefined) {
            
            nodeFlows.persistenceManager.getQueueItemFromHistory(queueItemId, function (queueItem) {
                callback(queueItem);
            });
        }
        else {
            callback(queueItem);
        }
    });
}



//Look for a new job...
function lookForNewWork(queueWorkerId) {

    //function should not be needed anymore?
    return;

    var queueWorker = queueWorkers[queueWorkerId];
    //logManager.log("lookForNewWork_QueueWorkerId:" + queueWorkerId + " Type:" + queueWorker.type);
    queueWorker.addHistory({ task: "LookForWork", notes: "Looking for work" });
    if (queueWorker.status== QueueWorker.prototype.STATUS_BUSY){
        //logManager.log("lookForNewWork_SkippingDueToBusy:" + queueWorkerId + " Type:" + queueWorker.type);
        queueWorker.addHistory({task:"TooBusy", notes:"Already Busy"})
        return;
    }

    nodeFlows.persistenceManager.getQueue(function (queueStorage) {




        for (var queueItemId in queueStorage) {

            var queueItem = new QueueItem(queueStorage[queueItemId]);
            //var queueItem = queueStorage[queueItemId];


            queueWorker.addHistory({ task: "Checking", notes: "QueueItem:" + queueItem._id + "/Type:" + queueItem.type });

            if (queueItem.status === "resume" && queueItem.type === queueWorker.type) {

                logManager.log("Found a queueItem that can be resumed:" + queueItemId, "", exports.SUBSYSTEM);
                queueItem.updateQueueItem({ status: "busy" }, function () {
                    
                    queueWorker.addHistory({ task: "Found eligible resume queueItem", notes: "queueItemId:" + queueItemId });
                    queueItem.addHistory({ task: "Resuming", notes: "Resuming task2.  queueWorkerId:" + queueWorkerId });
                    queueWorker.takeQueueItem(queueItem);
                    //queueWorker.addHistory({ task: "queueItem taken", notes: "queueItemId:" + queueItemId });
                    //process.nextTick(function () {
                    nodeFlows.processWorkflow(queueItem.workflowId);
                    //});
                });

                

            }

            else if (queueItem.status == "waiting" && queueItem.type == queueWorker.type) {
                logManager.log("lookForNewWork:Found new item to run:" + queueItemId + " type:" + queueWorker.type, "", exports.SUBSYSTEM);

                queueWorker.addHistory({ task: "Found eligible waiting queueItem", notes: "queueItemId:" + queueItemId });

                try {

                    queueItem.addHistory({ task: "Resuming", notes: "Found Waiting task" });
                    log("resuming task in waiting state", "", exports.SUBSYSTEM);
                    queueWorker.takeQueueItem(queueItem);
                    log("queueWorker took queueitem", "", exports.SUBSYSTEM);
                    queueItem.getWorkflow(function (workflow) {
                        log("before gotonextstep", "", exports.SUBSYSTEM);
                        workflow.gotoNextStep(function () {
                            log("going to next step", "", exports.SUBSYSTEM);
                            process.nextTick(function () {
                                log("starting to process again", "", exports.SUBSYSTEM);
                                workflow.processWorkflow();
                            });
                        });
                    });
                }
                catch (ex) {
                    logManager.logException(ex);
                }
            }



        }

        queueWorker.addHistory({ task: "NoQueueItems", notes: "No Work For Me!" })
        //queueWorker.idleCount = queueWorker.idleCount + 1;

    });




}

function moveQueueItemToHistory(queueItemId){
    log("queueManager_moveQueueItemToHistory:" + queueItemId, "", exports.SUBSYSTEM);

    //Dont put into history if it is not enabled
    if (queueItemHistoryEnabled) {

        
        getQueueItem(queueItemId,function(queueItem){

            nodeFlows.persistenceManager.persistQueueItemToHistory(queueItem,function(){
                //Remove the queueItem from the active queueItem storage
                //delete queueStorage[queueItemId];
                nodeFlows.persistenceManager.removeQueueItem(queueItemId);
            });
        });
    }
    else
    {
        //Remove the queueItem from the active queueItem storage
        //delete queueStorage[queueItemId];
        nodeFlows.persistenceManager.removeQueueItem(queueItemId);
    }


};

