
var fs = require("fs");
var logManager = require("./logManager.js");
var log = require("./logManager.js").log;
var logException = require("./logManager.js").logException;
var logError = require("./logManager.js").logError;
var statManager = require("./statManager.js");
var queueManager = require("./queueManager.js");
var nodeFlows = require('./nodeFlows');
var activityManager = require("./activityManager.js");

//var persistenceManager = nodeFlows.persistenceManager;




exports.getWorkflowModule = getWorkflowModule;
exports.getWorkflowDefinitions = getWorkflowDefinitions;
exports.getActiveWorkflows = getActiveWorkflows;
exports.getWorkflowHistory = getWorkflowHistory;
exports.getWorkFlowHistoryItem = getWorkFlowHistoryItem;
exports.moveWorkflowToHistory = moveWorkflowToHistory;
exports.processWorkflowActivity = processWorkflowActivity;
exports.getWorkflow = getWorkflow;
exports.incrementWorkingStorageValue = incrementWorkingStorageValue;
exports.getWorkingStorageValue = getWorkingStorageValue;
exports.getWorkflowHistoryCount = getWorkflowHistoryCount;

exports.SUBSYSTEM = "Workflow";
exports.MODULE = "Manager";

var workflowPathRoot = "./node_modules/nodeFlows/workflows/";

var workflowDefinitionStorage = undefined;
var path = "";

//var activeWorkflows = {};
//var workflowHistory = [];

//This is storage for any environmental variables accessed or manipulated by workflows
var workingStorage = {};

//Determines whether or not a history is stored for workflows
log("Defaulting workflowHistoryEnabled to true")
var workflowHistoryEnabled = true;

Object.defineProperty(exports, 'workflowHistoryEnabled', {
    get: function () {
        log("Get workflowHistoryEnabled:" + workflowHistoryEnabled);
        return workflowHistoryEnabled;
    },
    set: function (val) {
        log("Set workflowHistoryEnabled to:" + val);
        workflowHistoryEnabled = val;
    }
});



statManager.statsEmitter.on('SecondTimer', function(args) {
    //logging.log("workflowManager second timer");
}); 

//Management for Workflow definitions
if (workflowDefinitionStorage === undefined) {
    log("Reading workflow definitions");
    readWorkflowDefinitions(path);
};

function getWorkflowHistoryCount(callback){
    logManager.throwIfUndefined(callback, "A callback is needed");

    nodeFlows.persistenceManager.getWorkflowHistoryCount(function(workflowCount) {
            callback(workflowCount);
        });

};


function getWorkingStorageValue(valueName, callback){
    var workingStorageValue = workingStorage[valueName];
     if (workingStorageValue === undefined) {
         log("Initializing working storage value:" + valueName);
         workingStorageValue = { value: 0 };
         workingStorage[valueName] = workingStorageValue;
     }

    callback(workingStorageValue);
}

function incrementWorkingStorageValue(valueName, incrementAmount, callback){
    log("workflowManager_incrementWorkingStorageValue:" + valueName + " amount:" + incrementAmount);
     var workingStorageValue = workingStorage[valueName];
     if (workingStorageValue === undefined) {
         log("Initializing working storage value:" + valueName);
         workingStorageValue = { value: 0 };
         workingStorage[valueName] = workingStorageValue;
     }
     workingStorageValue.value = workingStorageValue.value + incrementAmount;
     log("new working storage value:" + JSON.stringify(workingStorageValue));

    callback();
}


function getWorkflow(workflowId, callback) {
    try {
        log("workflowManager_getWorkflow:" + workflowId);
        statManager.statsEmitter.emit('StatEvent2', {subsystem:exports.SUBSYSTEM,module:exports.MODULE,statName:"getWorkflow"});
        nodeFlows.persistenceManager.retrieveWorkflowInstance(workflowId, function(workflow) {
            callback(workflow);
        });
    }
    catch(ex){
        logException(ex);
    }
}

function getWorkflowDefinitions() {
    var workflowDefinitions = [];
    for(var workflow in workflowDefinitionStorage) {
        workflowDefinitions.push(workflowDefinitionStorage[workflow]);
    }
    return workflowDefinitions;
}

function readWorkflowDefinitions(path) {
    statManager.statsEmitter.emit('StatEvent2', {subsystem:exports.SUBSYSTEM,module:exports.MODULE,statName:"readWorkflowDefinitions"});
    
    workflowDefinitionStorage = {};
    fs.readdir(workflowPathRoot + path, function(err, files) {
        if(err) throw err;
        files.forEach(function(file) {

            var stat = fs.statSync(workflowPathRoot + path + file);

            if(stat.isDirectory()) {
                //logging.log("Is A Directory");
                if(file != "Inactive") {                //Skip loading files in active directory
                    readWorkflowDefinitions(path + file + "/");
                }
            }
            else {
                //logging.log("Is a file");
                log("Adding workflow from file:" + path + file);
                var workflowName = (path + file).replace(".js", "");
                log("workflowname:" + workflowName);
                var workflow = { name: workflowName };
                var workflowModule = require("./workflows/" + path + file);
                workflow.module = workflowModule;
                //workflows.push(workflow)
                workflowDefinitionStorage[workflowName] = workflow;

                if(workflowModule.workflowDefinition.workers == undefined) {
                    queueManager.addQueueWorker(workflowName);
                } else {
                    for(var i = 0; i < workflowModule.workflowDefinition.workers; i++) {
                        queueManager.addQueueWorker(workflowName);
                    }
                }


            }
        });
    });
}

function getWorkflowModule(name) {
    //log("Finding Workflow Definition:" + name);
    return workflowDefinitionStorage[name];
}

//Management for Active Workflows

function getActiveWorkflows(callback) {
    //log("workflowManager_getActiveWorkflows");
    nodeFlows.persistenceManager.allWorkflowInstances(function(workflowInstances) {
        callback(workflowInstances);
    });
};

function processWorkflowActivity(workflow, callback) {
    try {
        log("workflowManager.processWorkflowActivity");

        var workflowStep = workflow.getWorkflowStep(workflow.currentStepName);
        log("Workflow step:" + workflowStep.Name + " Type:" + workflowStep.Type);
        workflow.addHistory({ task: "ProcessActivity", notes:workflowStep.Name + "(" + workflowStep.Type + ")" });

        if (workflowStep.Type == "Init"){
            log("Skipping the Init Step");
            callback({ result: "success" });
            return;
        }

        var activityType = activityManager.getActivity(workflowStep.Type)

         if(activityType == undefined) {
            logError("Undefined activity:" + workflowStep.Type);
            callback({result: "fail", notes:"Undefined activityType:" + workflowStep.Type});
            return;
        }

        var activity = activityType.module;

        if(activity == undefined) {
            logError("Undefined activity:" + workflowStep.Type);
            callback({result: "fail", notes:"Undefined activity module:" + workflowStep.Type});
            return;
        };
        //copy the initial args into new object
        var args = {};
        for(var property in workflowStep.args) {
            args[property] = workflowStep.args[property];
        };

        activity.executeActivity(workflow, args, function (results) {

            workflow.addHistory({ task: "ActivityResult", notes: JSON.stringify(results) });

            if (results.success == false) {
                log("Activity returned failure");
                callback({ result: "wait" });
                return;
            }
            else {
                if (workflowStep.success !== undefined) {
                    //A success step is included
                    if (workflowStep.success.statistic !== undefined) {
                        statManager.statsEmitter.emit('WorkflowEvent', workflowStep.success.statistic);
                    };
                };

                statManager.statsEmitter.emit('StatEvent2', {subsystem:exports.SUBSYSTEM,module:exports.MODULE,statName:"Step:" + workflow.workflowType + "/" + workflowStep.Name});

                //statManager.statsEmitter.emit('StatEvent', "Step:" + workflow.workflowType + "/" + workflowStep.Name);
                callback({ result: "success", nextStep: results.nextStep });
                return;
            }
        });
    }
    catch(ex) {
        logException(ex);
    }
}


//Management for Workflow history
function getWorkflowHistory(callback) {
    nodeFlows.persistenceManager.getWorkflowHistory(function(items) {
        callback(items);
    });

    //callback(workflowHistory);
}

function getWorkFlowHistoryItem(workflowId,callback){
    logManager.throwIfUndefined(callback, "A callback is needed");
    
    log("getWorkFlowHistoryItem:" + workflowId);
    
    nodeFlows.persistenceManager.retrieveWorkflowInstanceFromHistory(workflowId, function(item) {
        callback(item);
    });


}

function moveWorkflowToHistory(workflow){
    if (workflowHistoryEnabled) {
        //workflowHistory.push(workflow);
        nodeFlows.persistenceManager.persistWorkflowToHistory(workflow, function () {
            nodeFlows.persistenceManager.removeWorkflowInstance(workflow._id, function () {
                //do nothing
            });
        });
    }
    else
    {
        nodeFlows.persistenceManager.removeWorkflowInstance(workflow._id, function () {
            //do nothing
        });
    }

}


