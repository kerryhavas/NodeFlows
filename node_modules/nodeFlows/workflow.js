

var logManager = require('./logManager.js');
var log = require('./logManager.js').log;
var logException = require('./logManager.js').logException;
var logError = require("./logManager.js").logError;
var nodeFlows = require('./nodeFlows');
var workflowManager = require("./workflowManager.js");
var statManager = require("./statManager.js");
var queueManager = require("./queueManager.js");
var historyManager = require('./historyManager');

exports.SUBSYSTEM = "Workflow";
exports.MODULE = "Workflow";


exports.Workflow = function Workflow(type, initialData) {

    logManager.log("Initializing Workflow:" + JSON.stringify(initialData), "", exports.SUBSYSTEM);

    logManager.log("Initializing ID:" + typeof (initialData._id), "", exports.SUBSYSTEM);
    if (initialData._id === undefined) {
        //This is a new workflow
        this.workflowType = type;
        this.workflowDefinition = null;
        this.status = "idle";
        this._id = queueManager.getUniqueId();
        this.queueItemId = null;
        this.queueWorkerId = null;
        this.timeStamp = new Date().getTime();
        this.lastWorkflowId = null;
        this.activityCount = 0;
        this.idleCount = 0;
        this.busyCount = 0;
        this.currentStepName = null;
        this.completeTimeStamp = null;
        this.addHistory({ task: "Created", notes: "Type:" + type });
        if (initialData !== undefined) {
            this.initialize(initialData);
        }

    }
    else {
        //This is being hydrated from persistence
        logManager.log("Hydrating persisted Workflow:" + JSON.stringify(initialData), "", exports.SUBSYSTEM);
        this.hydrate(initialData);
        this.addHistory({ task: "Hydrated", notes: "Type:" + type });
    }

};



exports.Workflow.prototype = {

    STATUS_PAUSED: "Paused",
    STATUS_COMPLETE: "Complete",
    STATUS_RESUME: "resume",
    STATUS_BUSY: "busy",
    STATUS_ERROR: "Error",
    STATUS_IDLE: "idle",
    STATUS_BLOCKED: "Blocked",
    SUBSYSTEM: "workflow",

    processWorkflow: function () {
        var workflow = this;
        workflowManager.processWorkflowActivity(this, function (results) {
            if (results.result == "success") {
                if (workflow.status === workflow.STATUS_PAUSED) {
                    workflow.getQueueWorker().releaseQueueWorker("Paused");
                    workflow.addHistory({ task: "Paused", notes: "Paused from Process" });
                    return;
                }
                else if (workflow.status === workflow.STATUS_BLOCKED) {
                    //Workflow is blocked by something
                    workflow.addHistory({ task: "Blocked", notes: "Workflow is Blocked" });
                    workflow.getQueueItem(function (queueItem) {
                        queueItem.workItemBlocked("StatusReturnedBlocked");
                    });

                }
                else if (workflow.status != "Complete") {
                    if (results.nextStep !== undefined) {
                        workflow.setNextStep(results.nextStep, function () {
                            process.nextTick(function () {
                                workflow.processWorkflow();
                            });
                        });
                    }
                    else {
                        workflow.gotoNextStep(function () {
                            process.nextTick(function () {
                                workflow.processWorkflow();
                            });
                        });
                    };

                };

            }
            else {
                workflow.addHistory({ task: "ActivityFailed", notes: results.notes });
                workflow.status = workflow.STATUS_ERROR;
                workflow.getQueueItem().workItemBlocked("ActivityFailed");
            }
        });
    },
    workflowCompleted: function (callback) {
        //Workflow is complete
        var workflow = this;
        this.updateWorkflow({ status: this.STATUS_COMPLETE, completeTimeStamp: new Date().getTime() }, function () {
            workflow.getQueueItem(function (queueItem) {
                queueItem.queueItemComplete("Done", function () {

                });

                workflowManager.moveWorkflowToHistory(workflow);

                logManager.log("Completed Workflow:" + workflow._id, "", exports.SUBSYSTEM);
                callback();
            });
        });
    },
    incrementWorkingStorageValue: function (valueName, incrementAmount, callback) {
        workflowManager.incrementWorkingStorageValue(valueName, incrementAmount, function () {
            callback();
        });
    },
    getWorkingStorageValue: function (valueName, callback) {
        workflowManager.getWorkingStorageValue(valueName, function (value) {
            callback(value);
        });
    },
    pauseWorkflow: function (notes) {
        this.status = this.STATUS_PAUSED;
        this.getQueueWorker().releaseQueueWorker("Paused");
        this.addHistory({ task: "Paused", notes: "Paused by calling workflow_pauseWorkflow" });
        this.getQueueItem().status = "Paused";
    },
    resumeWorkflow: function (notes) {
        this.status = this.STATUS_RESUME;
        this.getQueueItem().status = "resume";
        this.addHistory({ task: "Resumed", notes: "Resumed by calling workflow_resumeWorkflow" });
    },
    addHistory: function (history) {
        try {
            if (this.queueItemId !== null) {
                if (history.queueItemId === undefined) {
                    history.queueItemId = this.queueItemId;
                }
            };
            history.workflowId = this._id;
            history.workflowType = this.workflowType;
            history.enabledOverride = this.historyRequested;

            //log("historyRequested:" + this.historyRequested);
            statManager.statsEmitter.emit('History', { subsystem: this.SUBSYSTEM, id: this._id, history: history });
            //historyManager.addHistory(nodeFlows.SUBSYSTEM_WORKFLOW, this._id, history);

            if (this.queueItemId !== null) {
                this.getQueueItem(function (queueItem) {
                    if (queueItem != undefined) {
                        queueItem.addHistory(history);
                    }
                });
            }

        }
        catch (ex) {
            logException(ex);
        }
    },
    getWorkflowDefinition: function () {
        //log("getWorkflowDefinition:" + this.workflowType);
        return workflowManager.getWorkflowModule(this.workflowType).module.workflowDefinition;
    },
    getWorkflowModule: function () {
        log("getWorkflowModule:" + this.workflowType);
        return workflowManager.getWorkflowModule(this.workflowType).module;
    },
    hydrate: function (persistedData) {
        logManager.log("Hydrating Workflow:" + JSON.stringify(persistedData), "", exports.SUBSYSTEM);
        //TODO does this need a deep copy?
        for (var property in persistedData) {
            this[property] = persistedData[property];
        }
        logManager.log("Workflow after hydration:" + JSON.stringify(this), "", exports.SUBSYSTEM);
    },
    initialize: function (initialData) {
        var workflow = this;
        log("Initializing Workflow:" + JSON.stringify(initialData), "", exports.SUBSYSTEM);
        var definitionData = this.getWorkflowDefinition().Steps[0];

        this.addHistory({ task: "InitializeFromDefinition", notes: JSON.stringify(definitionData.args) });

        for (var property in definitionData.args) {
            this[property] = definitionData.args[property];
        }

        this.addHistory({ task: "InitializeFromStep", notes: JSON.stringify(initialData) });
        for (var property in initialData) {
            this[property] = initialData[property];
        }

        log("Initializing currentStepName to " + definitionData.Name, "", exports.SUBSYSTEM);
        this.currentStepName = definitionData.Name;

        if (this.queueItemId != undefined) {
            logManager.log("Workflow created for queueItemId:" + this.queueItemId, "", exports.SUBSYSTEM);
            nodeFlows.queueManager.getQueueItem(this.queueItemId, function (queueItem) {
                queueItem.addHistory({ task: "WorkflowCreated", notes: "type:" + this.workflowType });
                //queueItem.workflowId = workflow._id;
                queueItem.updateQueueItem({workflowId:workflow._id}, function () {

                });
            });

        }
        if (this.queueWorkerId != undefined) {
            logManager.log("Workflow created for queueWorkerId:" + this.queueWorkerId, "", exports.SUBSYSTEM);
            var queueWorker = nodeFlows.queueManager.getQueueWorker(this.queueWorkerId);
            queueWorker.addHistory({ task: "WorkflowCreated", notes: "type:" + this.workflowType });
            queueWorker.workflowId = this._id;
        }
        if (this.initiatingQueueItemId != undefined) {
            logManager.log("Workflow created for initiatingQueueItemId:" + this.initiatingQueueItemId, "", exports.SUBSYSTEM);
        }
        if (this.initiatingQueueWorkerId != undefined) {
            logManager.log("Workflow created for initiatingQueueWorkerId:" + this.initiatingQueueWorkerId, "", exports.SUBSYSTEM);
        }
    },
    getWorkflowStep: function (stepName) {
        log("getWorkflowStep:" + stepName, "", exports.SUBSYSTEM);
        if (stepName == undefined) {
            stepName = this.getWorkflowDefinition().Steps[0].Name;
        }
        var i = 0;
        for (i = 0; i < this.getWorkflowDefinition().Steps.length; i++) {
            var step = this.getWorkflowDefinition().Steps[i];
            //logging.log("comparing:" + step.Name + " to " + stepName);
            if (step.Name == stepName) {
                //logging.log("Found Step:" + stepName);
                return step;
            }
        }
        log("Failed to find step:" + stepName, "", exports.SUBSYSTEM);
    },
    queueWorkerAssigned: function (queueWorkerId) {
        log("workflow_queueWorkerAssigned:" + queueWorkerId, "", exports.SUBSYSTEM);
        this.queueWorkerId = queueWorkerId;
        this.addHistory({ task: "WorkerAssigned", notes: "queueWorkerId:" + queueWorkerId });
    },
    getNextNumericalStep: function (stepName) {
        log("getNextNumericalStep:" + stepName, "", exports.SUBSYSTEM);
        var i = 0;
        for (i = 0; i < this.getWorkflowDefinition().Steps.length; i++) {
            var step = this.getWorkflowDefinition().Steps[i];
            //logging.log("comparing:" + step.Name + " to " + stepName);
            if (step.Name == stepName) {
                //logging.log("Found Step:" + stepName);
                if (i >= this.getWorkflowDefinition().Steps.length) {
                    return null;
                }
                else {
                    return this.getWorkflowDefinition().Steps[i + 1];
                }

            }
        }
        logManager.log("Failed to find step:" + stepName, "", exports.SUBSYSTEM);
    },
    getQueueItem: function (callback) {
        logManager.throwIfUndefined(callback, "A callback is needed");

        log("getQueueItem:" + this.queueItemId, "", exports.SUBSYSTEM);
        nodeFlows.queueManager.getQueueItem(this.queueItemId, function (queueItem) {
            log("getQueueItem retrieved:" + JSON.stringify(queueItem), "", exports.SUBSYSTEM);
            callback(queueItem);
        });

    },
    getQueueWorker: function () {
        log("getQueueWorker:" + this.queueWorkerId, "", exports.SUBSYSTEM);
        return nodeFlows.queueManager.getQueueWorker(this.queueWorkerId);
    },
    gotoNextStep: function (callback) {
        //Have the workflow figure out and set the next step
        log("gotoNextStep:" + this.currentStepName, "", exports.SUBSYSTEM);
        var workflow = this;
        var currentStep = this.getWorkflowStep(this.currentStepName);
        if (currentStep.nextStep == null) {
            log("gotoNextStep:Next Step is Null", "", exports.SUBSYSTEM);
            var nextNumericalStep = this.getNextNumericalStep(this.currentStepName);
            if (nextNumericalStep == null) {
                log("nextNumericalStep:Next Step is Null", "", exports.SUBSYSTEM);
                this.addHistory({ task: "NoNextStep", notes: "CurrentStep:" + this.currentStepName + ".  No NextStep could be found." });
                this.updateWorkflow({ status: "Error" }, function () {
                    workflow.getQueueItem().workItemBlocked("NoNextStep");
                });
                return;
            }
            else {
                this.setNextStep(nextNumericalStep.Name, function () {
                    log("gotoNextStep1:New Step is:" + workflow.currentStepName, "", exports.SUBSYSTEM);
                    callback();
                    return;
                });
            }
        }
        else {
            this.setNextStep(currentStep.nextStep, function () {
                log("gotoNextStep2:New Step is:" + this.currentStepName, "", exports.SUBSYSTEM);
                callback();
            });
        }
    },
    setNextStep: function (nextStep, callback) {
        log("Workflow_setNextstep", "", exports.SUBSYSTEM);
        if (nextStep == undefined) {
            var currentStep = this.getWorkflowStep(this.currentStepName);
            log("Defaulting next step to:" + currentStep.nextStep, "", exports.SUBSYSTEM);
            nextStep = currentStep.nextStep;
        }
        if (nextStep === null) {
            this.addHistory({ task: "NoNextStep", notes: "Can this happen?" })
            //TODO   What to do?
        }
        log("setNextStep:" + nextStep, "", exports.SUBSYSTEM);
        this.addHistory({ task: "GoToStep", notes: nextStep })

        //statManager.statsEmitter.emit('StatEvent', "setNextStep");
        var workflow = this;
        this.getWorkflowDefinition().Steps.some(function (step) {
            //log("Comparing Step:" + step.Name + " to " + nextStep);
            if (step.Name == nextStep) {
                log("Found Step:" + nextStep, "", exports.SUBSYSTEM);

                if (step.active === undefined) step.active = true;

                if (step.active == true) {
                    log("Found active step:" + nextStep, "", exports.SUBSYSTEM);
                    workflow.currentStepName = nextStep;
                    if (nextStep == null) {
                        log("nextStep is null", "", exports.SUBSYSTEM);
                        workflow.addHistory({ task: "NoNextStep2", notes: "Can this happen?" })
                        logError("workflow_setNextStep_NoNextStep2");
                        //TODO
                    }
                    else {
                        workflow.updateWorkflow({ currentStepName: nextStep }, function () {
                            callback();
                        });
                    }

                    return true;
                }
                else {
                    log("Step is inactive.  skip to next step", "", exports.SUBSYSTEM)
                    workflow.addHistory({ task: "SkipInactiveStep", notes: "" });

                    workflow.currentStepName = nextStep;
                    workflow.gotoNextStep(function () {
                        callback();
                    });
                    return true;
                }
            }
        });
    },
    persist: function (callback) {
        log("workflow_persist", "", exports.SUBSYSTEM);
        nodeFlows.persistenceManager.updateWorkflowInstance(this);
        callback();
    },

    updateWorkflow: function (updateData, callback) {
        log("updateWorkflow:" + this._id.toString(), "", exports.SUBSYSTEM);

        this.addHistory({ task: "Updated", notes: JSON.stringify(updateData) });

        for (var property in updateData) {
            this[property] = updateData[property];
        }

        nodeFlows.persistenceManager.updateWorkflowInstance(this._id.toString(), updateData, function () {
            if (callback != undefined) {
                callback(null); //TODO: add error handling
            };
        });
        //callback();
    },
    getInitiatingWorkflow: function (callback) {
        workflowManager.getWorkflow(this.initiatingWorkflow, function (workflow) {
            callback(workflow);
        });
    },
    evaluateCondition: function (condition, args) {
        //Called by activities as a way to evaluate various conditions
        var conditionResults = { condition: condition, hasError: false };
        if (condition === null) { //A null condition returns true
            workflow.addHistory({ task: "DefaultCondition" });
            conditionResults.results = true;
        }
        try {
            var evalCondition = eval("(" + condition + ")");
            this.addHistory({ task: "Condition", notes: condition + "=" + evalCondition });
            conditionResults.results = evalCondition;
        }
        catch (ex) {
            logException(ex, "Condition:" + condition);
            conditionResults.hasError = true;
            conditionResults.errorName = ex.name
            conditionResults.message = ex.message
            conditionResults.stack = ex.stack;

            this.addHistory({ task: "ConditionError", notes: condition + "(name:" + ex.name + "/message:" + ex.message + "/stack:" + ex.stack + ")" });

        }
        return conditionResults;

    }


};
