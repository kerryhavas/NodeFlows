
var logManager = require('./logManager.js');
var log = require('./logManager.js').log;
var logError = require('./logManager.js').logError;
var historyManager = require('./historyManager');
var queueManager = require("./queueManager.js");
var QueueItem = require("./queueItem.js");

var statManager = require("./statManager.js");

exports.STATUS_BUSY = "busy";

exports.QueueWorker = function QueueWorker(type) {
    this.type = type;
    this.status = "idle";
    this._id = queueManager.getUniqueId();
    this.workflowId = null;
    this.queueItemId = null;
    this.lastWorkflowId = null;
    this.activityCount = 0;
    this.idleCount = 0;
    this.busyCount = 0;
    this.timeStamp = new Date().getTime();
    this.lastActivity = null;
    this.lockedBy = null;
    this.STATUS_PAUSED = "Paused";

    var queueWorker = this;
    process.setMaxListeners(50);

    statManager.statsEmitter.on('QueueWorkerNeeded', function (queueItem) {
        //turn off
        //return;
        queueWorker.processWorkerRequest(queueItem);

        //};
    });


    queueWorker.lookForWorkInterval = 1000;
    queueWorker.checkForWorkInterval = undefined;
    queueWorker.activateWorkCheckInterval();
    //   = setInterval(function () {
    //      queueWorker.addHistory({ task: "Wake", notes: "Wake and Look for Work" });
    // }, lookForWorkInterval);


};

exports.QueueWorker.prototype = {

    STATUS_PAUSED: "Paused",
    STATUS_COMPLETE: "Complete",
    STATUS_BUSY: "busy",
    STATUS_ERROR: "Error",
    STATUS_IDLE: "idle",
    STATUS_SLEEPING: "sleeping",

    processWorkerRequest: function (queueItem) {

        this.addHistory({ task: "WorkerRequestReceived", notes: JSON.stringify(queueItem) });

        //Check if I am already busy
        if (this.status === exports.STATUS_BUSY) {
            this.addHistory({ task: "TooBusy", notes: "I'm already busy:" + queueItem._id });
            return;
        };

        //Check if it is a type I can process
        if (this.type !== queueItem.type) {
            this.addHistory({ task: "NotMyType", notes: "We are just not right for each other:" + queueItem._id });
            return;
        }

        //Check if someone else already grabbed it
        if (queueItem.status === queueManager.QUEUE_ITEM_STATUS.BUSY) {
            log("QueueWorker_QueueWorkerNeeded_QueueItem has been taken by someone else:" + queueItem.type, "", exports.SUBSYSTEM);
            this.addHistory({ task: "AlreadyTaken", notes: "Another queueWorker Already grabbed it:" + queueItem._id });
            return;
        };


        //if (queueWorker.status == QueueWorker.prototype.STATUS_IDLE) {
        this.addHistory({ task: "RightForMe", notes: "queueItem is right for me and i'm available:" + queueItem._id });
        //log("QueueWorker_QueueWorkerNeeded_Match_Type:" + queueItem.type);
        //log("QueueWorker_QueueWorkerNeeded_Match:" + queueWorker._id);
        //log("QueueWorker_QueueWorkerNeeded_WorkflowId:" + queueItem.workflowId);

        this.takeQueueItem(queueItem);

        queueItem.getWorkflow(function (workflow) {
            //log("QueueWorker_QueueWorkerNeeded_WorkflowId:" + workflow._id);

            workflow.processWorkflow();
        });

    },
    activateWorkCheckInterval: function () {
        var queueWorker = this;
        this.checkForWorkInterval = setInterval(function () {
            queueWorker.addHistory({ task: "Wake", notes: "Wake and Look for Work" });
            queueManager.lookForNewWork(queueWorker._id);
        }, this.lookForWorkInterval);
    },
    releaseQueueWorker: function (notes) {
        //Workflow is complete
        this.addHistory({ task: "releaseQueueWorker", queueItemId: this.queueItemId, workflowId: this.workflowId, notes: notes });
        this.activityCount++;
        this.lastWorkflowId = this.workflowId;
        this.workflowId = null;
        this.status = this.STATUS_IDLE;
        this.queueItemId = null;
        this.idleCount = 0;
        this.lastActivity = new Date().getTime();
        this.lockedBy = null;

        var queueWorkerId = this._id;
        process.nextTick(function () {
            queueManager.lookForNewWork(queueWorkerId);
        });
    },
    getQueueItem: function () {
        return queueManager.getQueueItem(this.queueItemId);
    },
    takeQueueItem: function (queueItem) {
        var worker = this;
        //Takes ownership of Queue Item and prepares to process it
        this.status = this.STATUS_BUSY;
        this.queueItemId = queueItem._id;
        this.addHistory({ task: "takeQueueItem", queueItemId: this.queueItemId, notes: "initiatingQueueItemId: " + queueItem.initiatingQueueItemId });

        queueItem.updateQueueItem({lockedBy:this._id,status:queueManager.QUEUE_ITEM_STATUS.BUSY,queueWorkerId:this._id}, function () {

            queueItem.addHistory({ task: "WorkerAssigned", notes: "queueWorkerId" + worker._id });

            
            queueItem.getWorkflow(function (workflow) {
                //log("queueItem_getWorkflow:" + workflow);
                //worker.addHistory({ task: "takeQueueItem2", queueItemId: worker.queueItemId, notes: "thisitemid: " + worker._id });
                workflow.queueWorkerAssigned(worker._id);
                //workflow.queueWorkerId = this._id;

            });
        });



    },
    addHistory: function (history) {
        try {
            //log("queueManager.queueWorkerHistoryEnabled:" + queueManager.queueWorkerHistoryEnabled);
            if (!queueManager.queueWorkerHistoryEnabled) return;

            if (this.queueWorker !== null) {
                if (history.queueWorker === undefined) {
                    history.queueWorker = this.queueWorker;
                }
            };

            if (this.queueItemId !== null) {
                if (history.queueItemId === undefined) {
                    history.queueItemId = this.queueItemId;
                }
            };
            statManager.statsEmitter.emit('History', { subsystem: queueManager.SUBSYSTEM_QUEUEWORKER, id: this._id, history: history });

            //historyManager.addHistory(queueManager.SUBSYSTEM_QUEUEWORKER, this._id, history);
        }
        catch (ex) {
            logManager.logException(ex);
        }
    },
    process: function () {
        //process the queueworkers stuff
        var queueWorker = this;



        setTimeout(function () {
            //logError("Status:" + this.STATUS_IDLE);
            if (queueWorker.status === queueWorker.STATUS_BUSY) {
                queueWorker.busyCount++;
            }
            else if (queueWorker.status === queueWorker.STATUS_IDLE) {
                queueWorker.idleCount++;
            }
            else if (queueWorker.status == queueWorker.STATUS_SLEEPING) {
                //queueWorker.status = queueWorker.STATUS_IDLE;
            }
            else {
                //queueWorker.status = queueWorker.STATUS_SLEEPING;
            }
            //queueWorker.idleCount++;
            queueWorker.process();
        }, 100);


    }

};
